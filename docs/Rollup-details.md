## Technical Walkthrough: Deploying an Arbitrum-Decaf Rollup on AWS with Espresso Integration

This section provides a step-by-step guide to launching a live Arbitrum Orbit chain (Nitro rollup) integrated with Espresso’s confirmation network (codename “Decaf”). We will use the Decaf testnet for Espresso and Arbitrum’s Sepolia test network as the L1 (base layer) for our Orbit chain, following Espresso’s official guide ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=%22parent)) ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=,must%20be%20a%20WebSocket%20URL)). By the end, we’ll have a functional “Arbitrum-Decaf” rollup running on an AWS EC2 instance, with Espresso HotShot confirmations enabled.

### **Step 1: Prepare the AWS EC2 Environment**

- **Launch an EC2 Instance:** Choose an AWS EC2 instance (e.g., Ubuntu 20.04 LTS or Amazon Linux 2) with sufficient resources (at least 2 vCPUs and 4-8 GB RAM to run an L2 node and auxiliary services). Ensure you allow inbound access to necessary ports (we’ll use 8547, 8548, 8549, 8550 for the rollup and Espresso services in this setup).
- **Install Dependencies:** SSH into the EC2 and install Docker and Docker Compose (the Espresso quickstart uses Docker containers for the rollup node). For Ubuntu, update apt and run `sudo apt-get install -y docker.io docker-compose` (or install Docker Compose plugin). Add your user to the `docker` group or use `sudo` for Docker commands. Verify by running `docker --version` and `docker compose version`. Also install git and Node.js (for any script tools).
- **Security Credentials:** Ensure you have your AWS SSH key for file transfers. If you plan to use CloudWatch logs, create an IAM role with AmazonEC2ContainerServiceforEC2Role or CloudWatchLogs permissions (the official guide suggests an EC2 role for CloudWatch logging, but this is optional).

### **Step 2: Clone Required Repositories**

We will use Espresso’s provided repositories to set up the rollup and Espresso integration:

- **Arbitrum Nitro Contracts (Espresso integration fork):** Clone the repository that contains deployment scripts and configs. For example, Espresso Systems provides a fork of Arbitrum Nitro contracts with Espresso support. Run: `git clone https://github.com/offchainlabs/nitro-contracts.git` and checkout the Espresso integration branch if needed. This repo includes Hardhat scripts to deploy the rollup contracts on L1 ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=Deploy%20contracts%20to%20Sepolia)) ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=Copy%20,the%20associated%20espresso%20contracts%20initialized)).
- **Espresso “Build Something Real” (Quickstart Config):** Clone the quickstart config repository, which includes Docker Compose files and chain configs. For example: `git clone https://github.com/EspressoSystems/espresso-build-something-real.git`. This contains a ready-to-use configuration for a dummy rollup, including `docker-compose.yml` and config files for both the rollup node and the “caffeinated” node (Espresso-integrated confirmation node).
- **Espresso Hackathon Example (optional):** Clone `git clone https://github.com/EspressoSystems/hackathon-example.git --recursive`. This is a Go project used to monitor Espresso confirmations ([repomix-output-https_--github.com-EspressoSystems-hackathon-example-.md](file://file-RniKA2FP9GrB3QdF7oQ7Ai#:~:text=This%20is%20a%20Go%20application,unauthorized%20transfers%20or%20drained%20funds)) ([repomix-output-https_--github.com-EspressoSystems-hackathon-example-.md](file://file-RniKA2FP9GrB3QdF7oQ7Ai#:~:text=The%20application%20uses%20a%20configuration,to%20customize%20the%20following%20parameters)). While not needed to run the chain, it provides a reference for reading confirmation events from the Espresso network. We will refer to it when integrating confirmations into BrewBridge logic later.

*(Make sure to include submodules where applicable. The hackathon-example has a `go-ethereum` submodule which you pull with `git submodule update --init --recursive` ([repomix-output-https_--github.com-EspressoSystems-hackathon-example-.md](file://file-RniKA2FP9GrB3QdF7oQ7Ai#:~:text=)).)*

### **Step 3: Deploy Rollup Contracts on Arbitrum Sepolia (L1)**

Before running the rollup node, we need to deploy the Arbitrum Orbit chain contracts on the L1 (Sepolia testnet in this case). The Nitro contracts repository provides scripts to do this:

1. **Install Hardhat and Build Contracts:** In the `nitro-contracts` directory, run `yarn install` and `yarn build` to compile the Arbitrum core contracts ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=Compile%20these%20contracts%20locally%20by,running)). Also run `yarn build:forge` if required (to compile any foundry tests or additional contracts).
2. **Configure Environment:** Copy the sample env: `cp .env.sample.goerli .env` (the sample might be named for Goerli; we’ll repurpose for Sepolia since both are Ethereum testnets). Edit the `.env` file:
   - Provide a funded private key (with Sepolia ETH) for deployment (`DEPLOYER_PRIVATE_KEY=...`).
   - Provide an Infura or Alchemy WebSocket RPC URL for Sepolia (`L1_RPC_WSS_URL=wss://...sepolia...`) – **use a WebSocket endpoint**, as required for the rollup config ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=parent,network%2Fv0)).
   - Provide an Etherscan API key (to verify contracts if needed).
   - If the Espresso integration requires an Espresso Light Client contract address, ensure it’s set. (According to docs, a `RollupCreator` contract with Espresso support is pre-deployed on Sepolia) ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=private%20key%20which%20has%20some,the%20associated%20espresso%20contracts%20initialized)). The sample `.env` may include `ROLLUP_CREATOR_ADDRESS` which can be set to the address given by Espresso Systems (for Decaf testnet).
3. **Deploy RollupCreator (if needed):** The Espresso integration requires a specialized RollupCreator contract on L1 that knows about Espresso’s light client and TEE verifier. Espresso Systems **already deployed one on Sepolia** with the Espresso contracts initialized ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=private%20key%20which%20has%20some,the%20associated%20espresso%20contracts%20initialized)). If you have the address (provided in the docs or in `espresso-deployments/sepolia.json` in the repo), you can skip deploying it. If you want your own, run `npx hardhat run scripts/deployment.ts --network sepolia` to deploy a new RollupCreator and the associated Espresso light client contracts ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=If%20you%20want%20to%20deploy,the%20steps%20on%20step%203)) ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=Run%20the%20following%20command%20to,and%20initialize%20the%20espresso%20contracts)). (This will use your deployer key and consume some Sepolia ETH.)
4. **Create the Orbit Rollup:** Update `scripts/config.ts.example` with your desired rollup parameters and rename it to `config.ts` ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=4)). Important fields include chain name and chain ID for your L2, and a reference to the `ROLLUP_CREATOR_ADDRESS`. Use a unique chain ID (e.g., 10000000 as in the example) that doesn’t clash with existing networks. After config, run: `npx hardhat run scripts/createEthRollup.ts --network sepolia` ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=4)). This script calls the RollupCreator on Sepolia to actually instantiate your new Arbitrum chain. If successful, it will output the addresses of the core contracts (Bridge, Inbox, SequencerInbox, Rollup, etc.) and generate an L2 genesis **chain config file**.

   *The deployed contract addresses are saved in `espresso-deployments/sepolia.json` ([repomix-output-EspressoSystems-nitro-contracts.md](file://file-QYk5bGgoqmvChZ135QDFNG#:~:text=Deployed%20contract%20addresses)). Also note the `ROLLUP_ADDRESS` (the Rollup contract) and other addresses, as well as the chain’s ID and genesis info for the node configuration.*

### **Step 4: Configure the Rollup Node (Caffeinated Rollup)**

With the rollup created on L1, we prepare the config for the L2 node. The `espresso-build-something-real` repository supplies default config files in its `config/` directory. Key files to edit or verify:

- **`config/l2_chain_info.json`:** This JSON describes the new chain to the Arbitrum node. Ensure the fields match the output from the deployment:
  - `chain-name` can be a friendly name.
  - `parent-chain-id` should be the numeric chain ID of the parent (in our case, if the parent is an Arbitrum chain on Sepolia, use that ID; if it’s directly Ethereum Sepolia, use Sepolia’s chain ID – the example uses 421614 which presumably is “Arbitrum Sepolia”) ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=%7B%20%22chain,url%22%3A)).
  - `parent-chain-is-arbitrum`: set to `false` if the L1 is Ethereum (Sepolia) or `true` if settling to an Arbitrum chain. (In our case, since we created the rollup on Ethereum Sepolia, this would be `false`. If instead the rollup were settling on Arbitrum Goerli, it would be `true`.)
  - Under `chain-config`, set the `chainId` to your rollup’s chain ID (e.g. 10000000) ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=%22chain,0)). Other genesis parameters can remain as default (they configure fork rules, ArbOS, etc.).
  - Under `rollup`, update the contract addresses: fill in `bridge`, `inbox`, `sequencer-inbox`, `rollup`, etc. with the addresses output by the deployment script ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=%7D%2C%20,utils%22%3A%20%22VALIDATOR_UTILS_ADDRESS)). (These addresses correspond to contracts on L1 Sepolia that the rollup will interact with.)
  - Keep `native-token` as `0x0` (ETH is native).
  - `deployed-at` is the L1 block height when the rollup was deployed (the script likely sets a default like 100000000 or the actual block number; use what the script output provided).
- **`config/full_node.json`:** Configuration for the main rollup node (often acting as sequencer in dev mode).
  - Ensure it references `l2_chain_info.json` (the docker compose mounts this) and has the correct paths.
  - Set the L1 RPC URL for the node: in the `full_node.json`, there will be a section for the L1 connection. Use your Ethereum Sepolia RPC (could be an Infura HTTPS endpoint) so the node can read L1 blocks and inbox messages.
  - Check that `validator.jwtsecret` or similar points to `val_jwt.hex` if needed for validator authentication.
- **`config/validation_node_config.json`:** Config for a secondary validation node (to simulate a verifier). Ensure the `jwtsecret` path matches the one used by the sequencer node (so they share the token for communication) ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=%7D%2C%20%22api,%7D)). The provided `val_jwt.hex` contains a sample secret ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=File%3A%20config%2Fval_jwt.hex%20)) (the one in the example is a placeholder hash; you can generate a new one for security).
- **`caff-node/config/caff_node.json`:** This is critical for Espresso integration. It configures the **Caffeinated Node** that connects to Espresso’s HotShot network:
  - Set `parent-chain-node-url` to a **WebSocket** endpoint of your L1. For Sepolia via Infura, for example: `"parent-chain-node-url": "wss://sepolia.infura.io/ws/v3/<your-key>"` ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=%22parent)) ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=,must%20be%20a%20WebSocket%20URL)). Using websockets is required for subscription to L1 events.
  - Set `chain.id` and `namespace` to your rollup’s chain ID (both values should match, e.g., 10000000) ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=,Update%20both%20values)).
  - Set `next-hotshot-block`: find the latest Decaf HotShot block from the Espresso block explorer (Decaf Testnet Explorer) and put that number ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=)). This ensures the node starts syncing from a recent HotShot block to save time.
  - Set `hotshot-url` to the Decaf testnet HotShot endpoint: e.g., `"hotshot-url": "https://query.decaf.testnet.espresso.network/v0"`. (The official guide uses a query endpoint for mainnet or testnet ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=parent,network%2Fv0))).
  - There will also be an `espresso-tee-verifier-addr`: for testnet Decaf, supply the address of the Espresso TEE verifier contract on Sepolia (Espresso Systems should provide this; for mainnet they gave `0xE68c...27Ed` ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=parent,network%2Fv0)), for Decaf testnet it will differ).
  - Other fields can remain as default (they handle enabling/disabling certain features; the example config already sets the node to sequencer mode and disables L1 posting since we handle that through the batcher in TEE).

Save all the changes to these config files. Double-check that the chain IDs and addresses are consistent across `l2_chain_info.json`, the Hardhat deployment outputs, and the caff node config.

### **Step 5: Launch the Rollup Node and Espresso (Decaf) Node**

Now we run the infrastructure using Docker Compose:

- **Start the Arbitrum Nitro Rollup Node:** In the root of `espresso-build-something-real` (where the main `docker-compose.yml` resides), run: `docker compose up -d` (the `-d` to run in detached mode, or omit for logs). This will spin up two containers as defined:
  - `nitro-node`: the primary Arbitrum node (likely running as sequencer) listening on ports 8547 (HTTP RPC), 8548 (likely P2P/engine), 8549 (WebSocket RPC) ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=version%3A%20%272,%228549%3A8549)). It uses `config/full_node.json`.
  - `validation_node`: a secondary node container running the Nitro validator binary (`nitro-val`) on port 8549 (we see it maps host 8949->container 8549) ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=validation_node%3A%20image%3A%20ghcr.io%2Fespressosystems%2Fnitro,val)). This uses `config/validation_node_config.json` and connects to the sequencer via the JWT secret for validating state.
  The first time, Docker will pull the `ghcr.io/espressosystems/nitro-espresso-integration/nitro-node:integration` image (which is a Nitro node with Espresso modifications). The compose is configured such that the `nitro-node` depends on `validation_node` (so the validator starts first) ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=)).
  - **Verify**: Run `docker ps` to ensure both containers are running. You can check logs with `docker compose logs -f nitro` to see the sequencer output. It should eventually show the chain starting and block production. The sequencer might produce blocks even if empty. The validator may log staking messages. (An initial harmless warning about “block validation pending” can occur when the rollup has no recent activity ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=If%20you%20see%20this%20error%3A,on%20or%20no%20new%20batches)) ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=error%20acting%20as%20staker%20err%3D,)) – you can ignore this and let it continue.)
- **Fund the Rollup (Deposit ETH):** Before we launch the Espresso caff node, make sure the rollup has at least one L2 account funded to pay for gas. Using Arbitrum’s standard bridge on Sepolia, deposit some ETH into the new rollup. Espresso’s guide suggests a command or script for this in the hackathon docs ([repomix-output-EspressoSystems-espresso-build-something-real.md](file://file-J9AjMDdr4fzzecJ3zBLc2j#:~:text=You%20need%20a%20funded%20wallet,found%20in%20the%20hackathon%20guide)). You can use Arbitrum’s **deposit CLI** or a simple contract call:
  - Identify the `EthBridge` or inbox address from the deployment (in `sepolia.json` or `l2_chain_info.json`). Using Hardhat console or Etherscan, call the deposit function to send ETH to L2. For example, Arbitrum’s Inbox contract method `depositEth(uint256)` can be used.
  - Alternatively, if an Orbit chain deployment portal or script was available, use that. The key is to have an address on L2 with ETH for gas. For testing, you might deposit to the sequencer’s own key or to your user key.
  - Once deposited (and after the rollup processes the L1 message), you’ll see the L2 balance appear. You can connect to the rollup RPC (http://<EC2-IP>:8547) with MetaMask by adding a custom network (chainId 10000000, currency ETH, RPC URL to your node). This allows you to verify the chain is running and the funds are there.
- **Start the Caffeinated Node (Espresso Confirmation Node):** Next, navigate to the `caff-node/` directory (inside the quickstart repo) which contains its own `docker-compose.yml` and config. Run: `docker compose up -d` here as well ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=2)). This will start the Espresso-integrated node which likely also uses the Nitro image but perhaps in a special mode:
  - The caff-node’s compose will run a container that connects to Espresso’s Decaf network. It might expose port 8550 (for JSON-RPC to allow queries, as indicated by hackathon example using 8550 for `caff_node_url` ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=Copy)) ([repomix-output-https_--github.com-EspressoSystems-hackathon-example-.md](file://file-RniKA2FP9GrB3QdF7oQ7Ai#:~:text=file%20allows%20you%20to%20customize,the%20following%20parameters))). Ensure your EC2’s security group allows inbound on 8550 if you want to access it externally.
  - This node will read the config in `caff-node/config/caff_node.json` that we edited. It connects to the same rollup chain data (we copied the database and config over) and also to the Espresso HotShot service.
  - **Copy necessary data**: If not already done, copy the L2 database and chain info to the caff-node folder as instructed in the official guide ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=1)) ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=,node%2Fconfig%60%20folder)):
    - `cp -r ./database ./caff-node/database` (from the rollup root to caff-node) – this ensures the caff node has the latest state.
    - Also copy `l2_chain_info.json` into `caff-node/config/`.
    - (These steps might have been done prior to launching, but it’s crucial the caff-node has the same genesis and state so it can sync the chain.)
  - The caff-node container should start and connect to Decaf. Check its logs (`docker compose logs -f caff-node` if the service is named as such) to see if it’s catching up to HotShot. It will likely log HotShot block heights or “connected to Espresso network” messages. If any errors (e.g., rate limit or syncing issues) occur, refer to Espresso docs troubleshooting ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=)) ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=Deploying%20your%20caffeinated%20node%20on,the%20cloud)).
  - Once running, the caff node essentially provides **Espresso confirmations** for your rollup. The rollup’s batch poster (running in TEE inside this node) will only post blocks that Espresso has confirmed, and it will attest to their order. The upshot: your L2 transactions now get a BFT-backed confirmation within a couple of seconds of inclusion, instead of waiting ~12 minutes for Ethereum finality ([Nitro Testnet | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/using-the-espresso-network-as-an-arbitrum-orbit-chain-migration/arbitrum-testnet/nitro-testnet#:~:text=The%20Espresso%20Network%20is%20a,15%20minutes)).

At this point, the Arbitrum-Decaf rollup is live on your EC2. You have:
- An L2 RPC endpoint (your EC2’s IP on port 8547) to interact with the rollup (for deploying BrewBridge contracts, etc.).
- The rollup is anchored on Sepolia testnet for security.
- Espresso Decaf providing fast confirmations via the caff node.

### **Verification:** You can test the setup by sending a test transaction on the L2 (e.g., a simple ETH transfer using MetaMask connected to the rollup). The transaction should appear in the Nitro node’s logs immediately. Within a couple seconds, the Espresso HotShot network will finalize it – you might observe a log on the caff node indicating a HotShot confirmation. While you can’t “see” the confirmation without a monitoring tool, you can use the hackathon example monitor:
   - Edit `hackathon-example/config/config.json` to point to your caff node RPC (e.g., `http://<EC2-IP>:8550`) ([Reading Confirmations from the Espresso Network | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/reading-confirmations-from-the-espresso-network#:~:text=Copy)) ([repomix-output-https_--github.com-EspressoSystems-hackathon-example-.md](file://file-RniKA2FP9GrB3QdF7oQ7Ai#:~:text=,to%20monitor%20for%20outgoing%20transactions)) and set the address (`from`) you want to monitor.
   - Run `go run .` in the hackathon-example project. It will print new transactions from that address and mark when they are detected ([repomix-output-https_--github.com-EspressoSystems-hackathon-example-.md](file://file-RniKA2FP9GrB3QdF7oQ7Ai#:~:text=This%20is%20a%20Go%20application,unauthorized%20transfers%20or%20drained%20funds)) ([repomix-output-https_--github.com-EspressoSystems-hackathon-example-.md](file://file-RniKA2FP9GrB3QdF7oQ7Ai#:~:text=,transaction%20details%20to%20the%20console)). This effectively shows that your caff node is feeding it confirmed blocks.

**Congratulations**, you now have a functional Orbit chain with Espresso confirmations on AWS. This chain will serve as the foundation for BrewBridge’s liquidity hub.

## Presentation-Style Summary of the Rollup’s Concept

To communicate the deployed rollup’s concept to stakeholders (e.g., in a presentation or pitch), we can summarize it as follows:

- **Custom Arbitrum Orbit Chain (L3):** We have launched a dedicated Arbitrum Orbit rollup, essentially our own Layer-3 blockchain that inherits security from Ethereum (via Arbitrum’s fraud proofs on the Sepolia testnet). This chain is exclusive to BrewBridge, allowing us to tailor its features for optimal cross-chain liquidity handling.
- **Espresso-Integrated (“Decaf”) Rollup:** Our rollup is augmented by Espresso’s global confirmation layer (code-named *Decaf* testnet for now). This means every block on our chain gets a near-instant confirmation by a decentralized BFT consensus (Espresso HotShot) ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=Rollups%20use%20HotShot%20to%20provide,the%20event%20of%20a%20safety)). In practice, transactions on BrewBridge’s chain are finalized in **2-3 seconds** with strong security guarantees, drastically improving user experience for bridging (no long waits or uncertain pending states).
- **Caffeinated Security:** The unique integration of a Trusted Execution Environment (TEE) and Espresso’s light client ensures our sequencer cannot misbehave (no reordering or withholding after Espresso confirms) ([Nitro Testnet | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/using-the-espresso-network-as-an-arbitrum-orbit-chain-migration/arbitrum-testnet/nitro-testnet#:~:text=This%20is%20a%20strong%20assumption%2C,finalized%20by%20the%20base%20layer)) ([Nitro Testnet | Espresso](https://docs.espressosys.com/network/guides/using-the-espresso-network/using-the-espresso-network-as-an-arbitrum-orbit-chain/using-the-espresso-network-as-an-arbitrum-orbit-chain-migration/arbitrum-testnet/nitro-testnet#:~:text=The%20user%20must%20trust%20that,blocks%20produced%20by%20the%20sequencer)). This provides users with a **double layer of trust**: the usual optimistic assumption of a honest majority of validators *plus* immediate finality backed by HotShot’s consensus of Ethereum stakers.
- **High Throughput, Low Cost:** By operating our own rollup, BrewBridge can offer high throughput (since we control block production) and low transaction fees for users. Settling to Ethereum (Sepolia) periodically ensures security, but most interactions happen quickly and cheaply on the L3.
- **Cross-Chain Connectivity:** The rollup is designed as a **connectivity hub** – it’s not an isolated chain, but rather one that constantly communicates with other networks. Using the Arbitrum bridging mechanisms on Ethereum and the Espresso confirmations for cross-chain messages, our rollup can trustlessly send and receive assets to/from external chains. In essence, this chain acts as the *meeting point* where liquidity from various chains converges.
- **Demo Ready:** We’ve deployed this rollup on cloud infrastructure, making it accessible to testers via standard Ethereum wallet tools (MetaMask, etc. by adding a custom network). It’s fully operational on test networks (Arbitrum Sepolia + Espresso Decaf), showcasing the cutting-edge capability of Orbit chains with fast finality. This sets the stage for **BrewBridge**, the application that lives on this rollup, to provide lightning-fast and secure cross-chain bridges.

*(In presentation format, the above points can be bullet points on a slide titled “BrewBridge Rollup (Arbitrum + Espresso)” with a diagram illustrating L1 Sepolia ↔ BrewBridge Rollup ↔ Espresso HotShot. Emphasize that this infrastructure is what powers the dApp’s speed and security.)*

## BrewBridge Architecture on the Rollup (and Espresso Confirmations in Bridging)

With the infrastructure in place, BrewBridge itself is an application built on top of this rollup chain. Here we break down how BrewBridge leverages the rollup and Espresso for its bridging operations:

- **Smart Contracts on the Rollup:** BrewBridge deploys a suite of smart contracts on the Arbitrum-Decaf rollup that handle liquidity pooling and cross-chain messaging. The core contract might be a **Liquidity Hub contract** that holds pools of various tokens (e.g., wrapped assets from other chains) and manages mint/burn of those wrapped tokens. For each supported external chain, BrewBridge could have a token bridge contract on the rollup that corresponds to that chain’s assets. When users deposit assets from an external chain, the rollup contract mints an equivalent wrapped asset into the unified pool. When users want to withdraw to a target chain, the contract burns the wrapped tokens and triggers a message to the target chain for release.
- **Bridging Model:** BrewBridge primarily uses a **lock-mint / burn-release model**, enhanced by unified liquidity:
  - **Deposit (Lock & Mint):** Suppose a user wants to bridge 100 USDC from Ethereum to Polygon via BrewBridge. The user would send 100 USDC to BrewBridge’s *Ethereum lock contract*. That contract (possibly the Arbitrum Bridge or a specialized BrewBridge Ethereum contract) locks the USDC and sends a message (via Arbitrum’s inbox mechanism or a relayer) to the BrewBridge rollup. On the rollup, the BrewBridge contract receives the message that “100 USDC deposited by UserX on Ethereum” – thanks to **Espresso confirmations, the rollup can trust this message quickly** if Ethereum (source) or our rollup (destination) is Espresso-enabled ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=chains%20in%20unison%2C%20providing%20protection,with%20chains%20that%20share%20the)) ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=bridging%20between%20rollups%20in%20a,used%20to%20transfer%20and%20swap)). The BrewBridge rollup contract mints 100 “USDC.e” (a wrapped USDC token representing USDC from Ethereum) into the unified liquidity pool.
  - **Unified Pool Routing:** Now that the liquidity is on the hub, the user can immediately initiate a transfer to Polygon. The AI route engine will see that we have 100 USDC.e available and possibly existing liquidity for Polygon (say, some USDC.p for Polygon in the pool). If liquidity is sufficient on the destination side, BrewBridge can **direct release**: it will burn 100 USDC.e from the pool and signal BrewBridge’s *Polygon release contract* to send 100 real USDC to the user on Polygon. If direct liquidity on Polygon is insufficient, the engine might find an alternate route (perhaps swap into another asset that has liquidity to Polygon, or queue the transfer until a liquidity provider fulfills it).
  - **Withdrawal (Burn & Release):** For the final leg, the rollup contract uses Espresso’s cross-chain confirmation to expedite the release. Since our rollup is confirmed by HotShot, it can **prove** to the Polygon bridge contract that the burn event occurred with finality. For EVM chains, this could be done via a light client on Polygon that watches the rollup’s outbox or via a relayer that waits for Espresso’s BFT finality instead of full L1 finality. Because Espresso provides a strong guarantee that the rollup state (including the burn event) will be finalized on L1, the Polygon contract can safely unlock/mint funds after a few seconds, rather than waiting minutes ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=HotShot%20speed%20and%20security%20go,the%20HotShot%20finality%20gadget%2C%20they)) ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=Rollups%20use%20HotShot%20to%20provide,the%20event%20of%20a%20safety)).
- **Use of Espresso Confirmations:** The **Espresso HotShot network** plays a pivotal role whenever BrewBridge needs to trust a cross-chain event:
  - When bridging *into* the rollup (from an external chain), if the source chain also uses Espresso (e.g., another Orbit chain with HotShot), BrewBridge’s rollup can recognize the deposit instantly as HotShot will finalize the source transaction across participating chains ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=which%20a%20determined%20state%20of,block)) ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=sequencers,used%20to%20transfer%20and%20swap)). If the source chain is a regular chain like Ethereum (without Espresso), BrewBridge may need to wait for a safe number of confirmations on that chain (or use a third-party relay service). However, Espresso still secures the *destination* rollup side: the moment our rollup picks up the deposit message, that inclusion is confirmed by HotShot, so the user sees the funds on BrewBridge chain with stronger assurance than just our sequencer’s word.
  - When bridging *out* of the rollup (to a target chain), BrewBridge leverages the fact that our rollup transaction (the burn event) is confirmed by HotShot. We can run a **relayer service** (perhaps as part of BrewBridge backend) that listens to the rollup’s events and, once HotShot confirms them, submits a proof or instruction to the target chain. Because HotShot consensus has attested to the order and execution of the burn, a cooperating verifier on the target chain can act after a fast confirmation. In essence, **Espresso acts as a decentralized watcher** that both BrewBridge and target chain contracts trust for finality. This reduces the risk window for attacks like chain reorgs or sequencer fraud when bridging assets ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=which%20a%20determined%20state%20of,Circle%E2%80%99s)) ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=HotShot%20speed%20and%20security%20go,owing%20to%20strong%20safety%20guarantees)).
- **AI Route Engine & Liquidity Logic:** BrewBridge’s off-chain component includes the route optimizer which continuously analyzes available liquidity on the rollup and known bridge routes. This engine might run on a Node.js backend or even as part of the front-end logic for MVP. It looks at metrics like current pool balances, estimated transfer times, and fees. For example, if bridging 100 USDC from Chain A to Chain C, and we have direct liquidity A->C versus going A->B->C through two transfers, it will choose the one with higher likelihood of success and lower cost. The engine might also interact with on-chain DEXes on the rollup for swaps – since the rollup can host AMMs, BrewBridge could swap the incoming asset to a different token that has better liquidity for the destination. All these decisions happen in seconds and the chosen plan is executed by instructing the BrewBridge contracts accordingly (e.g., perform a swap on the rollup, then initiate bridging out).
- **Liquidity Providers & Fees:** In the background, liquidity providers can add funds to BrewBridge’s rollup pools (by depositing assets from any chain into the hub, where they get minted as wrapped assets). BrewBridge could incentivize this by charging a small fee on each transfer (e.g., 0.1%) which goes to a fee pool on the rollup. LPs who stake assets in the pool earn from this fee pool, making it attractive to supply liquidity. The **unified pool** means an LP’s funds can facilitate transfers between any chain rather than being siloed; this maximizes capital efficiency.
- **Security Considerations:** The rollup inherits Ethereum-level security (optimistic rollup with fraud proofs) and immediate BFT finality from Espresso, making BrewBridge’s core as secure as current tech allows. BrewBridge’s contracts will be audited and initially limited in scope (no complex logic aside from mint/burn/swaps) to minimize vulnerability. If any anomaly happens (e.g., a bug or malicious sequencer attempt), Espresso’s shared finality can coordinate halting or rolling back if needed ([Bridging fast and safe with Espresso - HackMD](https://hackmd.io/@EspressoSystems/bridging#:~:text=which%20a%20determined%20state%20of,Circle%E2%80%99s)), preventing a compromised state from causing cross-chain damage. Additionally, since BrewBridge uses a permissioned sequencer (we run it) with accountability via TEE, the risk of malicious reordering or censorship is low and detectable.

In summary, BrewBridge is an application layer on the Arbitrum-Decaf rollup, orchestrating cross-chain moves. It uses the rollup for **execution and liquidity holding**, and Espresso for **fast finality of messaging**. This architecture allows users to deposit on one chain, have liquidity immediately available on the hub, and then withdraw on another chain with minimal delay, all under robust security.